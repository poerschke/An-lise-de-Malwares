unit Unit2;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, DCPcrypt2,
  DCPblockciphers, DCPrc5, DCPtwofish, DCPtea, DCPserpent, DCPrijndael, DCPrc6,
  DCPrc4, DCPrc2, DCPmisty1, DCPmars, DCPice, DCPidea, DCPdes, DCPcast256,
  DCPcast128, DCPblowfish, Vcl.ExtCtrls, DCPtiger, DCPsha512, DCPsha256,
  DCPsha1, DCPripemd160, DCPripemd128, DCPmd5, DCPmd4, DCPhaval, Vcl.ComCtrls,
  Vcl.TabNotBk, System.RegularExpressions, DCPBase64,IdHashMessageDigest, idHash, shellapi;

type
  TForm2 = class(TForm)
    ComboBox1: TComboBox;
    Label1: TLabel;
    RadioGroup2: TRadioGroup;
    RadioGroup3: TRadioGroup;
    Memo1: TMemo;
    Memo2: TMemo;
    Button1: TButton;
    Button2: TButton;
    Button3: TButton;
    Edit1: TEdit;
    Label2: TLabel;
    Label3: TLabel;
    ComboBox2: TComboBox;
    pg: TProgressBar;
    TabbedNotebook1: TTabbedNotebook;
    Label4: TLabel;
    Edit2: TEdit;
    Button4: TButton;
    Button5: TButton;
    pg2: TProgressBar;
    Limpar: TButton;
    RadioGroup1: TRadioGroup;
    RadioGroup4: TRadioGroup;
    Memo3: TMemo;
    Memo4: TMemo;
    Button6: TButton;
    Button7: TButton;
    Button8: TButton;
    RadioGroup5: TRadioGroup;
    RadioGroup6: TRadioGroup;
    Memo5: TMemo;
    Memo6: TMemo;
    Button9: TButton;
    Button10: TButton;
    RadioGroup7: TRadioGroup;
    Memo7: TMemo;
    RadioGroup8: TRadioGroup;
    Memo8: TMemo;
    op: TOpenDialog;
    Button11: TButton;
    Memo9: TMemo;
    Button12: TButton;
    Memo10: TMemo;
    procedure FormCreate(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure habilita();
    procedure ComboBox1Change(Sender: TObject);
    procedure ComboBox2Change(Sender: TObject);
    procedure ComboBox3Change(Sender: TObject);
    procedure ComboBox4Change(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure Button5Click(Sender: TObject);
    procedure LimparClick(Sender: TObject);
    procedure Button8Click(Sender: TObject);
    procedure Button6Click(Sender: TObject);
    procedure Button7Click(Sender: TObject);
    procedure Button10Click(Sender: TObject);
    procedure Button9Click(Sender: TObject);
    procedure Button11Click(Sender: TObject);
    procedure Button12Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form2: TForm2;

implementation

{$R *.dfm}

function MD5(const fileName : string) : string;
 var
   idmd5 : TIdHashMessageDigest5;
   fs : TFileStream;
   hash : T4x4LongWordRecord;
 begin
   idmd5 := TIdHashMessageDigest5.Create;
   fs := TFileStream.Create(fileName, fmOpenRead OR fmShareDenyWrite) ;
   try
     result := idmd5.HashStreamAsHex(fs);
   finally
     fs.Free;
     idmd5.Free;
   end;
 end;

function GetFileSize(const FileName: string): LongInt;
var
  SearchRec: TSearchRec;
begin
  try
    if FindFirst(ExpandFileName(FileName), faAnyFile, SearchRec) = 0 then
      Result := SearchRec.Size
    else Result := -1;
  finally
    FindClose(SearchRec);
  end;
end;

function StringToHex(S: String): string;
var I: Integer;
begin
  Result:= '';
  for I := 1 to length (S) do
    Result:= Result+IntToHex(ord(S[i]),2);
end;

function HexToString(H: String): String;
var I: Integer;
begin
  Result:= '';
  for I := 1 to length (H) div 2 do
    Result:= Result+Char(StrToInt('$'+Copy(H,(I-1)*2+1,2)));
end;

Function Crypt(Action, Src, senha: String): String;
Label Fim;
var KeyLen : Integer;
  KeyPos : Integer;
  OffSet : Integer;
  Dest, Key : String;
  SrcPos : Integer;
  SrcAsc : Integer;
  TmpSrcAsc : Integer;
  Range : Integer;
begin
  if (Src = '') Then
  begin
    Result:= '';
    Goto Fim;
  end;
  Key :=senha;
  Dest := '';
  KeyLen := Length(Key);
  KeyPos := 0;
  SrcPos := 0;
  SrcAsc := 0;
  Range := 256;
  if (Action = UpperCase('C')) then
  begin
    Randomize;
    OffSet := Random(Range);
    Dest := Format('%1.2x',[OffSet]);
    for SrcPos := 1 to Length(Src) do
    begin
      Application.ProcessMessages;
      SrcAsc := (Ord(Src[SrcPos]) + OffSet) Mod 255;
      if KeyPos < KeyLen then KeyPos := KeyPos + 1 else KeyPos := 1;
      SrcAsc := SrcAsc Xor Ord(Key[KeyPos]);
      Dest := Dest + Format('%1.2x',[SrcAsc]);
      OffSet := SrcAsc;
    end;
  end
  Else if (Action = UpperCase('D')) then
  begin
    OffSet := StrToInt('$'+ copy(Src,1,2));
    SrcPos := 3;
  repeat
    SrcAsc := StrToInt('$'+ copy(Src,SrcPos,2));
    if (KeyPos < KeyLen) Then KeyPos := KeyPos + 1 else KeyPos := 1;
    TmpSrcAsc := SrcAsc Xor Ord(Key[KeyPos]);
    if TmpSrcAsc <= OffSet then TmpSrcAsc := 255 + TmpSrcAsc - OffSet
    else TmpSrcAsc := TmpSrcAsc - OffSet;
    Dest := Dest + Chr(TmpSrcAsc);
    OffSet := SrcAsc;
    SrcPos := SrcPos + 2;
  until (SrcPos >= Length(Src));
  end;
  Result:= Dest;
  Fim:
end;


function ExtractText(Str: string; const Delim1: char): string;
var
  pos1, pos2: integer;
  str2 : String;
begin
  result := '';
  pos1 := Pos(Delim1, Str);
  str2 := copy(str, pos1+1, str.Length);

  pos2 := Pos(Delim1, Str2);
  str := Copy(Str2, 1, pos2-1);

  result := str;
end;








procedure TForm2.habilita();
begin
  if (combobox1.ItemIndex > -1) AND (combobox2.ItemIndex > -1) then
       button2.Enabled := true;
end;



procedure TForm2.LimparClick(Sender: TObject);
begin
  edit2.Clear;
  memo3.Clear;
  memo4.Clear;
end;

procedure TForm2.Button10Click(Sender: TObject);
begin
memo7.Clear;
memo8.Clear;

end;

procedure TForm2.Button11Click(Sender: TObject);
begin
if op.Execute() then
  begin
    memo9.Lines.Add('----------------------------------------');
    memo9.Lines.Add('Arquivo: '+ ansistring(op.FileName));
    memo9.Lines.Add('Tamanho: '+ inttostr(GetFileSize(ansistring(op.FileName))) + ' bytes');
    memo9.Lines.Add('MD5: '+ MD5(ansistring(op.FileName)));

    memo9.Lines.SaveToFile('binario.txt');
  end;

end;

procedure TForm2.Button12Click(Sender: TObject);
function GetDosOutput(CommandLine: string; Work: string = 'C:\'): string;
var
  SA: TSecurityAttributes;
  SI: TStartupInfo;
  PI: TProcessInformation;
  StdOutPipeRead, StdOutPipeWrite: THandle;
  WasOK: Boolean;
  Buffer: array[0..255] of AnsiChar;
  BytesRead: Cardinal;
  WorkDir: string;
  Handle: Boolean;
begin
  Result := '';
  with SA do begin
    nLength := SizeOf(SA);
    bInheritHandle := True;
    lpSecurityDescriptor := nil;
  end;
  CreatePipe(StdOutPipeRead, StdOutPipeWrite, @SA, 0);
  try
    with SI do
    begin
      FillChar(SI, SizeOf(SI), 0);
      cb := SizeOf(SI);
      dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES;
      wShowWindow := SW_HIDE;
      hStdInput := GetStdHandle(STD_INPUT_HANDLE); // don't redirect stdin
      hStdOutput := StdOutPipeWrite;
      hStdError := StdOutPipeWrite;
    end;
    WorkDir := Work;
    Handle := CreateProcess(nil, PChar('cmd.exe /C ' + CommandLine),
                            nil, nil, True, 0, nil,
                            PChar(WorkDir), SI, PI);
    CloseHandle(StdOutPipeWrite);
    if Handle then
      try
        repeat
          WasOK := ReadFile(StdOutPipeRead, Buffer, 255, BytesRead, nil);
          if BytesRead > 0 then
          begin
            Buffer[BytesRead] := #0;
            Result := Result + Buffer;
          end;
        until not WasOK or (BytesRead = 0);
        WaitForSingleObject(PI.hProcess, INFINITE);
      finally
        CloseHandle(PI.hThread);
        CloseHandle(PI.hProcess);
      end;
  finally
    CloseHandle(StdOutPipeRead);
  end;
end;
begin
memo10.Clear;
memo10.Lines.Append(GetDosOutput('strings.exe -nobanner -u -n 6 '+ ansistring(op.FileName), GetCurrentDir));
end;

procedure TForm2.Button1Click(Sender: TObject);
var
  X : integer;
  str : String;

begin
  pg.Min :=0;
  pg.Max := memo1.Lines.Count -1;
  for X := 0 to memo1.Lines.Count -1 do
  begin
    pg.Position := X;
    application.ProcessMessages;
    str := memo1.Lines.Strings[X];
    if pos('"', str) >= 1
     then
      begin
        str := ExtractText(str, '"');
        memo1.Lines.Strings[X] := str;
      end;

    if pos('''', str) >= 1
     then
      begin
        str := ExtractText(str, '''');
        memo1.Lines.Strings[X] := str;
      end;


  end;
  pg.Position:= 0;

end;

procedure TForm2.Button2Click(Sender: TObject);
var

C : TDCP_Cipher;
X, l : integer;
st : String;

begin
pg.Min := 0;
pg.Max := memo1.Lines.Count -1;

try
    for X := 0 to memo1.Lines.Count -1 do
      begin
        application.ProcessMessages;
        pg.Position := X;
        l := memo1.Lines.Strings[X].Length mod 4;
        if l = 0 then
        begin

          C := TDCP_Cipher.Create(nil);
          case combobox1.ItemIndex of
              0:      C := TDCP_tea.Create(nil);
              1:      C := TDCP_des.Create(nil);
              2:      C := TDCP_ice.Create(nil);
              3:      C := TDCP_rc2.Create(nil);
              4:      C := TDCP_rc4.Create(nil);
              5:      C := TDCP_rc5.Create(nil);
              6:      C := TDCP_rc6.Create(nil);
              7:      C := TDCP_3des.Create(nil);
              8:      C := TDCP_ice2.Create(nil);
              9:      C := TDCP_idea.Create(nil);
             10:      C := TDCP_mars.Create(nil);
             11:      C := TDCP_misty1.Create(nil);
             12:      C := TDCP_cast128.Create(nil);
             13:      C := TDCP_cast256.Create(nil);
             14:      C := TDCP_thinice.Create(nil);
             15:      C := TDCP_serpent.Create(nil);
             16:      C := TDCP_twofish.Create(nil);
             17:      C := TDCP_blowfish.Create(nil);
             18:      C := TDCP_rijndael.Create(nil);
          end;

          case combobox2.ItemIndex of
              0:      C.InitStr(ansistring(edit1.text), TDCP_md4);
              1:      C.InitStr(ansistring(edit1.text), TDCP_md5);
              2:      C.InitStr(ansistring(edit1.text), TDCP_sha1);
              3:      C.InitStr(ansistring(edit1.text), TDCP_haval);
              4:      C.InitStr(ansistring(edit1.text), TDCP_tiger);
              5:      C.InitStr(ansistring(edit1.text), TDCP_sha256);
              6:      C.InitStr(ansistring(edit1.text), TDCP_sha384);
              7:      C.InitStr(ansistring(edit1.text), TDCP_sha512);
              8:      C.InitStr(ansistring(edit1.text), TDCP_ripemd128);
              9:      C.InitStr(ansistring(edit1.text), TDCP_ripemd160);
          end;
          memo2.Lines.Append('Cifrado: '+ AnsiString(memo1.Lines.Strings[X]));
          memo2.Lines.Append('Decifrado:' + C.DecryptString(AnsiString(memo1.Lines.Strings[X])));
          memo2.Lines.Append('-----------------------------------------------------------');
          C.Burn;
          C.Free;
        end;
        end;
      pg.Position := 0;
finally

end;
     memo2.Lines.SaveToFile('Decriptado.txt');

end;

procedure TForm2.Button3Click(Sender: TObject);
begin
memo1.Clear;
memo2.Clear;
end;


procedure TForm2.Button4Click(Sender: TObject);
var
  X : integer;
  str : String;
  lista : TStringList;
begin
  pg2.Min :=0;
  pg2.Max := memo3.Lines.Count -1;
  lista := TStringList.Create;
    for X := 0 to memo3.Lines.Count -1 do
    begin
      pg2.Position := X;
      application.ProcessMessages;
      str := memo3.Lines.Strings[X];

      if pos('"', str) >= 1
        then
          begin
            str := ExtractText(str, '"');
            memo3.Lines.Strings[X] := str;
          end;

      if pos('''', str) >= 1
        then
          begin
            str := ExtractText(str, '''');
            memo3.Lines.Strings[X] := str;
          end;

      if TRegEx.IsMatch(memo3.Lines.Strings[X], '^[A-Fa-f0-9]+$') then
        if (memo3.Lines.Strings[x].Length mod 2 = 0) and (memo3.Lines.Strings[x].Length > 4) then
          lista.Add(memo3.Lines.Strings[X]);
    end;

    memo3.Lines := lista;
    pg2.Position:= 0;
    lista.Free;

end;

procedure TForm2.Button5Click(Sender: TObject);
var
X : integer;
begin
     for x := 0 to memo3.Lines.Count -1 do
       begin
         memo4.Lines.Append('--------------------------------');
         memo4.Lines.Append('Cifrado: '+ memo3.Lines.Strings[x]);
         try
          memo4.Lines.Append('Decifrado: '+ Crypt('D', memo3.Lines.Strings[x], edit2.Text));
         except
          memo4.Lines.Append('[-] Erro ao decifrar');
         end;
       end;
       memo4.Lines.SaveToFile('Cifrados.txt');
end;

procedure TForm2.Button6Click(Sender: TObject);
var
  X : integer;
  str : String;
  lista : TStringList;
begin
  lista := TStringList.Create;
    for X := 0 to memo5.Lines.Count -1 do
    begin
      application.ProcessMessages;
      str := memo5.Lines.Strings[X];

      if pos('"', str) >= 1
        then
          begin
            str := ExtractText(str, '"');
            memo5.Lines.Strings[X] := str;
          end;

      if pos('''', str) >= 1
        then
          begin
            str := ExtractText(str, '''');
            memo5.Lines.Strings[X] := str;
          end;

      if TRegEx.IsMatch(memo5.Lines.Strings[X], '^[A-Fa-f0-9]+$') then
          lista.Add(memo5.Lines.Strings[X]);
    end;

    memo5.Lines := lista;
    lista.Free;

end;

procedure TForm2.Button7Click(Sender: TObject);
var
X: integer;
begin

for x := 0 to memo5.Lines.Count -1 do
  begin
    memo6.Lines.Append('----------------------------');
    memo6.Lines.Append('Hexa: '+ memo5.Lines.Strings[x]);
    memo6.Lines.Append('String: '+ HexToString(memo5.Lines.Strings[x]));
  end;
  memo6.Lines.SaveToFile('Hexa.txt');

end;

procedure TForm2.Button8Click(Sender: TObject);
begin
memo5.Clear;
memo6.Clear;
end;

procedure TForm2.Button9Click(Sender: TObject);
var
x : integer;
begin
  for x := 0 to memo7.Lines.Count -1 do
    begin
      memo8.Lines.Append('----------------------------');
      memo8.Lines.Append('Base64: '+ memo7.Lines.Strings[x]);
      memo8.Lines.Append('String: '+ DCPBase64.Base64DecodeStr(AnsiString(memo7.Lines.Strings[x])));
    end;
  memo8.Lines.SaveToFile('Base64.txt');
end;

procedure TForm2.ComboBox1Change(Sender: TObject);
begin
 habilita();
end;

procedure TForm2.ComboBox2Change(Sender: TObject);
begin
habilita();
end;

procedure TForm2.ComboBox3Change(Sender: TObject);
begin
habilita();
end;

procedure TForm2.ComboBox4Change(Sender: TObject);
begin
habilita();
end;

procedure TForm2.FormCreate(Sender: TObject);
begin
  memo1.Clear;
  memo2.Clear;
  edit1.Clear;
  button2.Enabled := false;
  edit2.Clear;
  memo3.Clear;
  memo4.Clear;
  memo5.Clear;
  memo6.Clear;
  memo7.Clear;
  memo8.Clear;
  memo9.Clear;
  memo10.Clear;
end;

end.
